["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Object",["^ "]],"~:use-macros",["^ ","~$go-loop","~$cljs.core.async.macros"],"~:excludes",["~#set",[]],"~:name","~$keechma.toolbox.pipeline.controller","~:imports",null,"~:requires",["^ ","~$controller","~$keechma.controller","^>","^>","~$cljs.core.async","^?","~$keechma.toolbox.pipeline.core","^@","~$set","~$clojure.set","^B","^B"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$<!","^?","~$run-pipeline","^@"],"~:defs",["^ ","~$prepare-controller-api",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","~:line",36,"~:column",7,"~:end-line",36,"~:end-column",29,"~:arglists",["~#list",["~$quote",["^Q",[["~$controller-api"]]]]]],"^9","~$keechma.toolbox.pipeline.controller/prepare-controller-api","~:variadic",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",29,"~:method-params",["^Q",[["^S"]]],"~:protocol-impl",null,"~:arglists-meta",["^Q",[null,null]],"^M",1,"^L",36,"^N",36,"~:max-fixed-arity",1,"~:fn-var",true,"^P",["^Q",["^R",["^Q",[["^S"]]]]]],"~$default-params",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",34,"^M",6,"^N",34,"^O",20],"^9","~$keechma.toolbox.pipeline.controller/default-params","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",20,"^V",["^Q",[["~$route-params"]]],"^W",null,"^X",["^Q",[]],"^M",1,"^L",34,"^N",34,"^Y",1,"^Z",true,"^P",null],"~$make-constructor",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",66,"^M",7,"^N",66,"^O",23,"^P",["^Q",["^R",["^Q",[["^S","~$pipelines"]]]]]],"^9","~$keechma.toolbox.pipeline.controller/make-constructor","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",23,"^V",["^Q",[["^S","^13"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",66,"^N",66,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^S","^13"]]]]]],"~$->PipelineController",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",12,"^M",12,"^N",12,"^O",30,"~:internal-ctor",true,"~:factory","~:positional","^P",["^Q",["^R",["^Q",[["^S","^13"]]]]]],"^9","~$keechma.toolbox.pipeline.controller/->PipelineController","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",30,"^V",["^Q",[["^S","^13"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^16",true,"^17","^18","^L",12,"^N",12,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^S","^13"]]]]]],"~$prepare-pipelines",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",50,"^M",7,"^N",50,"^O",24,"^P",["^Q",["^R",["^Q",[["^13"]]]]]],"^9","~$keechma.toolbox.pipeline.controller/prepare-pipelines","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",24,"^V",["^Q",[["^13"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",50,"^N",50,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["^13"]]]]]],"~$map->PipelineController",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",12,"^M",12,"^N",12,"^O",30,"^16",true,"^17","~:map","^P",["^Q",["^R",["^Q",[["~$G__42971"]]]]]],"^9","~$keechma.toolbox.pipeline.controller/map->PipelineController","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",30,"^V",["^Q",[["^1>"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^16",true,"^17","^1=","^L",12,"^N",12,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1>"]]]]]],"~$PipelineController",["^ ","~:num-fields",2,"~:protocols",["^8",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^9","~$keechma.toolbox.pipeline.controller/PipelineController","^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",30,"~:type",true,"^M",12,"^16",true,"^L",12,"~:record",true,"^N",12,"~:skip-protocol-flag",["^8",["^1C","^1D","^1E","^1F","^1G","^1H","^1I","^1J","^1K","^1L","^1M","^1N","^1O","^1P"]]],"~$pipeline-rename-map",["^ ","^9","~$keechma.toolbox.pipeline.controller/pipeline-rename-map","^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",8,"^M",1,"^N",8,"^O",25,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",8,"^M",6,"^N",8,"^O",25],"~:tag","^1O"],"~$redundant-pipeline-message",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",45,"^M",7,"^N",45,"^O",33,"^P",["^Q",["^R",["^Q",[["~$pipeline"]]]]]],"^9","~$keechma.toolbox.pipeline.controller/redundant-pipeline-message","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",33,"^V",["^Q",[["^1Y"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",45,"^N",45,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1Y"]]]]]],"~$default-start-stop",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",33,"^M",6,"^N",33,"^O",24],"^9","~$keechma.toolbox.pipeline.controller/default-start-stop","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",24,"^V",["^Q",[["~$this","~$params","~$app-db"]]],"^W",null,"^X",["^Q",[]],"^M",1,"^L",33,"^N",33,"^Y",3,"^Z",true,"^P",null],"~$constructor",["^ ","^I",null,"^J",["^ ","^K","/Users/retro/Projects/dataloader-example/resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^L",71,"^M",7,"^N",71,"^O",18,"^P",["^Q",["^R",["^Q",[["^S","^13"]]]]],"~:doc","\nConstructor for the pipeline controller.\n\nPipeline controllers are special type of Keechma controllers that handle their commands with pipelines. Pipelines allow you to model a command / action as a series of steps. Pipelines know how to handle promises and they themselves return a promise.\n\nPipelines allow you to split async actions into distinct steps:\n\n- Pipeline processing\n- Sideffects\n\nIf a pipeline processing step returns a promise (for instance from an AJAX request), pipeline will wait until that promise is resolved before proceeding to the next step.\n\nSimple example\n\n```clojure\n(ns some-namespace\n  (:require [keechma.toolbox.pipeline.controller :as pp-controller]\n            [keechma.toolbox.pipeline.core :as pp :refer-macros [pipeline!]])\n\n(def some-controller\n  (fn [route-params] true) ;; route params function\n  {:start (pipeline! [value app-db]\n            (pp/commit! (assoc-in app-db [:kv :current-user-status] :loading))\n            (load-user-from-server)\n            (pp/commit! (->app-db\n                           (assoc-in [:kv :current-user-status] :loaded)\n                           (assoc-in [:kv :current-user] value))))})\n```\n\nIn the previous example three things happened:\n\n1. We stored current user status as `:loading` in the app-db\n2. We loaded user from the server\n3. We stored the current user status and the current user in the app-db\n\n`value` always holds the returned (or resolved) value from the previous processing step - unless the function returns `nil` in that case, value is bound to the previous value. Also, we had to use the `commit!` sideffect function to mutate the app-db.\n\n`value` and `app-db` arguments are always bound to the current pipeline value and to the current version of app-db. This means that in every processing step, value and app-db point to the results of the previous processing step.`\n\nIf we want to handle errors or rejections in pipelines, we can use the `rescue!` block:\n\n```clojure\n(def some-controller\n  (fn [route-params] true) ;; route params function\n  {:start (pipeline! [value app-db]\n            (pp/commit! (assoc-in app-db [:kv :current-user-status] :loading))\n            (load-user-from-server)\n            (pp/commit! (->app-db\n                           (assoc-in [:kv :current-user-status] :loaded)\n                           (assoc-in [:kv :current-user] value)))\n            (rescue! [error]\n              (pp/commit! (assoc-in app-db [:kv :current-user-status] :error))})\n```\n\nRescue block will catch any errors that happen in the pipeline - including the promises that were rejected. Steps in the rescue block have access to value and app-db arguments.\n\n**Nesting pipelines**\n\nSometimes you need to run the pipeline only if some condition is true. In that case you can nest pipelines:\n\n```clojure\n(def some-controller\n  (fn [route-params] true) ;; route params function\n  {:start (pipeline! [value app-db]\n            (when (= value true)\n              (pipeline! [value app-db]\n                (some-api-call)\n                (pp/commit! (mutate-app-db app-db)))))}) \n```\n\n**Pipeline sideffects**\n\nPipelines can have various sideffects:\n\n1. `commit!` - commits the new app-db version in the global app-db atom\n2. `send-command!` - sends command to another controller\n3. `execute!` - executes command in the current controller\n4. `redirect!` - redirects to a different URL\n\n**Exclusive pipelines**\n\nIn some cases you want to always run only one pipeline at a time. One example of that behavior is the live search. \n\nLet's say that you want to implement it as a command that runs on every key press. After the command is ran, it should wait for 500msec before calling the API. If the command is called again in these 500msec, stop the pipeline and run a new one.\n\nHere's how you would implement this feature:\n\n```clojure\n(def search-controller\n  (pp-controller/constructor\n   (fn [] true)\n   {:search (pp/exclusive\n             (pipeline! [value app-db]\n               (when-not (empty? value)\n                 (pipeline! [value app-db]\n                   (delay-pipeline 500)\n                   (movie-search value)\n                   (println \"SEARCH RESULTS:\" value)))))}))\n```\n  "],"^9","~$keechma.toolbox.pipeline.controller/constructor","^U",false,"^K","resources/public/js/dev/keechma/toolbox/pipeline/controller.cljs","^O",18,"^V",["^Q",[["^S","^13"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",71,"^N",71,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^S","^13"]]]]],"^25","\nConstructor for the pipeline controller.\n\nPipeline controllers are special type of Keechma controllers that handle their commands with pipelines. Pipelines allow you to model a command / action as a series of steps. Pipelines know how to handle promises and they themselves return a promise.\n\nPipelines allow you to split async actions into distinct steps:\n\n- Pipeline processing\n- Sideffects\n\nIf a pipeline processing step returns a promise (for instance from an AJAX request), pipeline will wait until that promise is resolved before proceeding to the next step.\n\nSimple example\n\n```clojure\n(ns some-namespace\n  (:require [keechma.toolbox.pipeline.controller :as pp-controller]\n            [keechma.toolbox.pipeline.core :as pp :refer-macros [pipeline!]])\n\n(def some-controller\n  (fn [route-params] true) ;; route params function\n  {:start (pipeline! [value app-db]\n            (pp/commit! (assoc-in app-db [:kv :current-user-status] :loading))\n            (load-user-from-server)\n            (pp/commit! (->app-db\n                           (assoc-in [:kv :current-user-status] :loaded)\n                           (assoc-in [:kv :current-user] value))))})\n```\n\nIn the previous example three things happened:\n\n1. We stored current user status as `:loading` in the app-db\n2. We loaded user from the server\n3. We stored the current user status and the current user in the app-db\n\n`value` always holds the returned (or resolved) value from the previous processing step - unless the function returns `nil` in that case, value is bound to the previous value. Also, we had to use the `commit!` sideffect function to mutate the app-db.\n\n`value` and `app-db` arguments are always bound to the current pipeline value and to the current version of app-db. This means that in every processing step, value and app-db point to the results of the previous processing step.`\n\nIf we want to handle errors or rejections in pipelines, we can use the `rescue!` block:\n\n```clojure\n(def some-controller\n  (fn [route-params] true) ;; route params function\n  {:start (pipeline! [value app-db]\n            (pp/commit! (assoc-in app-db [:kv :current-user-status] :loading))\n            (load-user-from-server)\n            (pp/commit! (->app-db\n                           (assoc-in [:kv :current-user-status] :loaded)\n                           (assoc-in [:kv :current-user] value)))\n            (rescue! [error]\n              (pp/commit! (assoc-in app-db [:kv :current-user-status] :error))})\n```\n\nRescue block will catch any errors that happen in the pipeline - including the promises that were rejected. Steps in the rescue block have access to value and app-db arguments.\n\n**Nesting pipelines**\n\nSometimes you need to run the pipeline only if some condition is true. In that case you can nest pipelines:\n\n```clojure\n(def some-controller\n  (fn [route-params] true) ;; route params function\n  {:start (pipeline! [value app-db]\n            (when (= value true)\n              (pipeline! [value app-db]\n                (some-api-call)\n                (pp/commit! (mutate-app-db app-db)))))}) \n```\n\n**Pipeline sideffects**\n\nPipelines can have various sideffects:\n\n1. `commit!` - commits the new app-db version in the global app-db atom\n2. `send-command!` - sends command to another controller\n3. `execute!` - executes command in the current controller\n4. `redirect!` - redirects to a different URL\n\n**Exclusive pipelines**\n\nIn some cases you want to always run only one pipeline at a time. One example of that behavior is the live search. \n\nLet's say that you want to implement it as a command that runs on every key press. After the command is ran, it should wait for 500msec before calling the API. If the command is called again in these 500msec, stop the pipeline and run a new one.\n\nHere's how you would implement this feature:\n\n```clojure\n(def search-controller\n  (pp-controller/constructor\n   (fn [] true)\n   {:search (pp/exclusive\n             (pipeline! [value app-db]\n               (when-not (empty? value)\n                 (pipeline! [value app-db]\n                   (delay-pipeline 500)\n                   (movie-search value)\n                   (println \"SEARCH RESULTS:\" value)))))}))\n```\n  "]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6"],"~:cljs.analyzer/constants",["^ ","~:seen",["^8",["~:else","~:controller-api","~:start","~:params","~:recur","~:on-route-changed","^S","~:stop","~:on-stop","~:pipelines","~:route-changed","^13","~:on-start"]],"~:order",["^2=","^2A","^2D","^2E","^2B","^2@","^2<","^2C","^S","^13","^2>","^2?","^2;"]],"^25",null]